From b21891f1ec8d992102b0ab3787c9f764c10a53c9 Mon Sep 17 00:00:00 2001
From: Jae Hyun Yoo <jae.hyun.yoo@intel.com>
Date: Tue, 30 Jul 2019 13:01:58 -0700
Subject: [PATCH] peci: add a temporary workaround

To cover a PECI issue, this commit makes PECI driver block all PECI
commands when PLTRST_N signal is 0.

Also, it adds 'use_wa' module parameter for platforms that don't have
the PLTRST_N gpio input so that the WA can be disabled through the
module parameter.

This is a temporary workaround.

Signed-off-by: Jae Hyun Yoo <jae.hyun.yoo@intel.com>
---
 drivers/misc/aspeed-espi-slave.c  |  3 +++
 drivers/peci/busses/peci-aspeed.c | 30 ++++++++++++++++++++++++++++++
 2 files changed, 33 insertions(+)

diff --git a/drivers/misc/aspeed-espi-slave.c b/drivers/misc/aspeed-espi-slave.c
index 06b038bba032..874fb3a1f1e0 100644
--- a/drivers/misc/aspeed-espi-slave.c
+++ b/drivers/misc/aspeed-espi-slave.c
@@ -96,6 +96,7 @@ struct aspeed_espi {
 
 static void aspeed_espi_sys_event(struct aspeed_espi *priv)
 {
+	extern void aspeed_peci_update_pltrst_n(char val);
 	u32 sts, evt;
 
 	regmap_read(priv->map, ASPEED_ESPI_SYSEVT_INT_STS, &sts);
@@ -126,6 +127,8 @@ static void aspeed_espi_sys_event(struct aspeed_espi *priv)
 	if (sts & ASPEED_ESPI_SYSEVT_PLTRSTN || priv->pltrstn == 'N') {
 		priv->pltrstn = (evt & ASPEED_ESPI_SYSEVT_PLTRSTN) ? '1' : '0';
 		wake_up_interruptible(&priv->pltrstn_waitq);
+		aspeed_peci_update_pltrst_n((evt & ASPEED_ESPI_SYSEVT_PLTRSTN) ?
+					     1 : 0);
 		dev_dbg(priv->dev, "SYSEVT_PLTRSTN: %c\n", priv->pltrstn);
 	}
 
diff --git a/drivers/peci/busses/peci-aspeed.c b/drivers/peci/busses/peci-aspeed.c
index 851b71e32eac..7bb225103061 100644
--- a/drivers/peci/busses/peci-aspeed.c
+++ b/drivers/peci/busses/peci-aspeed.c
@@ -10,6 +10,7 @@
 #include <linux/jiffies.h>
 #include <linux/module.h>
 #include <linux/of.h>
+#include <linux/of_gpio.h>
 #include <linux/peci.h>
 #include <linux/platform_device.h>
 #include <linux/reset.h>
@@ -124,8 +125,22 @@ struct aspeed_peci {
 	struct completion	xfer_complete;
 	u32			status;
 	u32			cmd_timeout_ms;
+	/* Temporary WA */
+	int			pltrst_pin;
 };
 
+/* Temporary WA */
+static bool use_wa __read_mostly = true;
+module_param_named(use_wa, use_wa, bool, 0644);
+MODULE_PARM_DESC(use_wa, "flag for enabling of WA");
+
+static char pltrst_n = 0;
+void aspeed_peci_update_pltrst_n(char val)
+{
+	pltrst_n = val;
+}
+EXPORT_SYMBOL_GPL(aspeed_peci_update_pltrst_n);
+
 static int aspeed_peci_check_idle(struct aspeed_peci *priv)
 {
 	ulong timeout = jiffies + usecs_to_jiffies(ASPEED_PECI_IDLE_CHECK_TIMEOUT_USEC);
@@ -165,6 +180,10 @@ static int aspeed_peci_xfer(struct peci_adapter *adapter,
 	if (ret)
 		return ret; /* -ETIMEDOUT */
 
+	/* Temporary WA */
+	if (use_wa && !pltrst_n)
+		return -EAGAIN;
+
 	spin_lock_irqsave(&priv->lock, flags);
 	reinit_completion(&priv->xfer_complete);
 
@@ -443,6 +462,17 @@ static int aspeed_peci_probe(struct platform_device *pdev)
 	if (ret)
 		goto err_put_adapter_dev;
 
+	/* Temporary WA */
+	priv->pltrst_pin = of_get_gpio(pdev->dev.of_node, 0);
+	if (gpio_is_valid(priv->pltrst_pin)) {
+		ret = devm_gpio_request(&pdev->dev, priv->pltrst_pin,
+					"peci-aspeed");
+		if (!ret) {
+			pltrst_n = gpio_get_value(priv->pltrst_pin);
+			devm_gpio_free(&pdev->dev, priv->pltrst_pin);
+		}
+	}
+
 	ret = peci_add_adapter(priv->adapter);
 	if (ret)
 		goto err_put_adapter_dev;
-- 
2.7.4

